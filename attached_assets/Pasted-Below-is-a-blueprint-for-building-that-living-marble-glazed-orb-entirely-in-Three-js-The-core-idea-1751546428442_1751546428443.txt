Below is a blueprint for building that living, marble-glazed orb entirely in Three.js. The core idea is to:

Create a high-res sphere

Write a custom GLSL shader that:

Lerps between your orange → magenta gradient

Adds Perlin/simplex noise to carve “veins”

Animates those veins over time via a time uniform

Mixes in an envMap for those glossy highlights

Drive the animation loop so both the veins and the orb rotation are constantly updating

1. Install & set up
bash
Copy
Edit
npm install three
In your HTML (or React mounting point) include:

html
Copy
Edit
<canvas id="canvas"></canvas>
2. Boilerplate
js
Copy
Edit
import * as THREE from 'three';

let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.z = 3;

let renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
3. Load an environment map for reflections
js
Copy
Edit
const envLoader = new THREE.CubeTextureLoader().setPath('/path/to/cubemap/');
const envMap = envLoader.load([
  'px.jpg','nx.jpg',
  'py.jpg','ny.jpg',
  'pz.jpg','nz.jpg',
]);
scene.background = envMap;
4. Define the marble shader material
js
Copy
Edit
// Simplex noise GLSL implementation (you can grab one from https://github.com/ashima/webgl-noise)
const NOISE_FUNC = `
// ... paste your 3D noise GLSL code here ...
`;

const uniforms = {
  time:    { value: 0 },
  color1:  { value: new THREE.Color(0xFF8A00) },
  color2:  { value: new THREE.Color(0xFF00FF) },
  envMap:  { value: envMap },
};

const orbMaterial = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    varying vec3 vNormal;
    varying vec3 vPos;
    void main(){
      vNormal = normalize(normalMatrix * normal);
      vPos    = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    precision highp float;
    varying vec3 vNormal;
    varying vec3 vPos;
    uniform float time;
    uniform vec3 color1;
    uniform vec3 color2;
    uniform samplerCube envMap;
    ${NOISE_FUNC}

    void main(){
      // Marble veins
      vec3 p = vPos * 2.0;
      p += time * 0.5;
      float n = snoise(p);               // range [-1,1]
      float vein = smoothstep(0.0, 0.5, n);

      // Gradient base
      vec3 baseColor = mix(color1, color2, vein);

      // Reflection for gloss
      vec3 R = reflect(normalize(vPos), normalize(vNormal));
      vec3 refl = textureCube(envMap, R).rgb;

      // Combine & gamma-correct
      vec3 finalColor = mix(baseColor, refl, 0.5);
      finalColor = pow(finalColor, vec3(1.0/2.2));

      gl_FragColor = vec4(finalColor, 1.0);
    }
  `,
});
5. Create the sphere mesh
js
Copy
Edit
const geometry = new THREE.SphereGeometry(1, 256, 256);
const orb = new THREE.Mesh(geometry, orbMaterial);
scene.add(orb);
6. Animate!
js
Copy
Edit
function animate(){
  requestAnimationFrame(animate);

  // advance time
  uniforms.time.value += 0.01;

  // slow spin
  orb.rotation.y += 0.002;

  renderer.render(scene, camera);
}
animate();
What’s happening?
Noise-driven veins: the GLSL noise function warps a gradient, carving random “marble” patterns.

Time uniform: shifting the noise input (p += time) makes those veins swirl and flow.

EnvMap reflection: adds that glossy highlight you see on your orb.

High segment counts (256×256) keep it smooth at close zooms.

You can drop this straight into a React component (or plain JS) and tweak the snoise scale, color stops, reflection mix, spin speed, etc., until it matches your reference image exactly. Let me know if you’d like a React-ifier or help swapping in your own cube-map textures!